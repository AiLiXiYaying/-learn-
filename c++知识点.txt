c++

1.	#include <iostream>
	#include <string>
知识点： #后方是预处理语句，意思是在编译之前就已经处理过了，所以才叫预处理。
******************************************************************************

2.	#include <iostream>
知识点：包含了iostream头文件后，才可以使用cout，cin等等。
******************************************************************************

3.	编译有四个阶段：预处理，编译阶段（C），汇编，链接阶段（LNK）.
编译的主要目的之一就是将高级编程语言的源代码转换为机器能够执行的二进制代码。这个过程包括了几个步骤：

预处理（Preprocessing）： 展开宏定义、处理条件编译等，生成经过预处理的源代码。

编译（Compilation）： 将预处理后的源代码翻译为汇编代码。

汇编（Assembly）： 将汇编代码翻译为机器码，生成目标文件（通常是 .obj 文件）。

链接（Linking）： 将所有目标文件和所需的库文件链接在一起，生成最终的可执行文件（通常是 .exe 文件）。

知识点：c2039就是指编译阶段出错。LNK2039就是链接阶段出错。这里的数字只是例子，不是具体数字。
******************************************************************************

4.	不同类型的变量之间的区别只有一种：大小。即该数据类型占多少内存。（原始数据类型的区别）
知识点：int     4字节，short   2字节

int-short>0（a-b>0），求得int占内存比short大，并且int取值范围也比short大。（实际数据类型所占字节根据编译器而定）

int范围在2b~-2b之间，即所占字节（4）先*8，求得所占位数为32，然后2^32/2-1求得int所在N集合范围的取值,然后求非正集合Z（不包括0）的取值范围为-（2^32）/2

之所以-1，是因为N集合包括0，在最大数上要-1来确保0计入。

集合表示为{x∈Z|-(2^32)/2<=x<=2^32/2-1}
******************************************************************************

5.	函数
知识点：多次反复利用，避免代码重复，函数一般称为代码块，在类中被称为方法。
******************************************************************************

6.	#pragma once
知识点：#pragma预处理指令是向编译器发送命令，#pragma once存在于头文件最顶端，是告诉编译器只包含一次该头文件。
******************************************************************************

7.	头文件.h
知识点：头文件中写声明，定义写在obj文件（源文件）或主函数所在文件中。
******************************************************************************

8.	visual studio文件
知识点：pdb文件提供调试所需信息，ilk可以增量编译，优化链接，idb文件进行支持增量编译。obj文件是.cpp文件被编译后形成的。obj文件内是二进制。
******************************************************************************

9.	双引号头文件与尖括号头文件
知识点：双引号头文件在当前项目中目录结构进行查找，尖括号头文件直接在整个系统中进行查找。
******************************************************************************

10.	调试的两大部分：断点与读取内存
知识点：调试时，断点所处位置出现黄色箭头，意思是将要执行此行代码。断点同时是为了查看程序是否按照预期执行，设置断点就是为了读取内存。visual studio2022中断点的快捷键是f9。
******************************************************************************

11.	debug
知识点：在程序中调试进行查找bug。
******************************************************************************

12.	visual studio2022输出and中间目录最佳设置
知识点:舒服就对了，输出目录为：$(SolutionDir)bin\$(Platform)\$(Configuration)\           中间目录为:$(SolutionDir)bin\intermediates\$(Platform)\$(Configuration)\ 
******************************************************************************

13.	循环
知识点：for循环，while循环，do while循环（唯独这个，先执行一次再判断）。需要多次执行时使用循环语句。
******************************************************************************

14.	控制流语句
知识点：continue，break，return。continue只能在循环中使用，作用为跳转至循环下一次迭代。break只能在循环或switch中使用，break的作用为终止循环。return为跳出函数。
******************************************************************************

15.	指针
知识点：获取地址，指针内部存放的是地址。
******************************************************************************

16.	16进制
知识点：0x3e8 = 1000.   3*16*16+e*16+8.   运算为百位*2个16，十位*1个16，个位不需要*。千位以此递推。*16的个数为当前位数-1.百位为3，-1 = 2， 所以百位上的数字*2个16.
******************************************************************************

17.	引用
知识点：为对象起别名，在实际编译中，引用的名字不存在，假设有变量a，还有引用ref，ref是a的引用，在实际编译中，只会出现a，ref不存在。引用只能绑定一个对象。
******************************************************************************

18.	面向对象
知识点：三大特性：封装，继承，多态。c++为面向对象语言，其他的语言还有c#，java......
******************************************************************************

19.	类
知识点：增加了可维护性，可以实现的功能用不用类都能实现。            类（Class）： 一个抽象的数据类型，描述了数据的结构和对数据执行的操作。            对象（Object）： 类的一个具体实例，占用内存空间，可以执行类定义的操作。
******************************************************************************

20.	类（class）与结构体（struct）
知识点：唯一的区别只有结构体默认为公有属性（public），类默认为私有（private）属性。之所以c++中依旧保持结构体，是因为保持对c的兼容，只需使用#define struct class即可。
******************************************************************************

21.	静态（static）
知识点：类，结构体内创建的静态为静态成员变量或静态成员函数，每个静态都在每个对象中共同存在，享用同一段内存。局部静态，只被初始化一次。全局静态，只存在于当前.cpp文件内，其他.cpp文件无法访问。静态成员变量和函数是属于类的，而非类的实例。
******************************************************************************

22.	运行阶段
知识点：运行阶段：在运行阶段，你执行生成的可执行文件。这时候不再需要编译或链接，只需运行已经生成好的二进制文件。操作系统加载可执行文件到内存中，并按照程序的入口点开始执行。
******************************************************************************

23.	枚举
知识点：全局调用时，无论是具名枚举还是匿名枚举，常量名称在相同的作用域内必须是唯一的。而枚举类引入了独立的作用域，允许不同的枚举类拥有相同的常量名称。
******************************************************************************

24.	构造函数
知识点：开始时调用一次，为当前对象的成员变量赋初始值。
******************************************************************************

25.	析构函数
知识点：结束时调用一次，在对象销毁的过程中，负责释放对象所拥有的资源，关闭文件，或执行其他必要的清理操作。
******************************************************************************

26.	继承
知识点：公有（public）继承，基类的公有成员在派生类当中依旧是公有的，基类的私有成员不继承给派生类，基类的保护成员全部为派生类的保护成员。私有成员不会被继承。

私有（private）继承，基类的公有成员，保护成员，全部变为派生类的私有成员。私有成员不会被继承。

保护（protected）继承，基类的公有成员，保护成员，全部变为派生类的保护成员。私有成员不会被继承。

共同点是，私有属性不管在什么继承中，都不会被继承，私有只存在于该类本身之中。
******************************************************************************

27.	虚函数
知识点：派生类不会被强制要求必须提供实现，派生类中没有实现时，会调用基类的虚函数本身的成员。通过基类指针或引用调用一个虚函数，实际上将调用与指针或引用关联的对象的类型中的函数，而不是指针或引用本身的类型。

同时，基类的析构函数也要变成虚析构函数，派生类的析构函数要加上关键字override.
******************************************************************************

28.	纯虚函数
知识点：要求任何派生类都必须提供自己的实现。

所处基类创建对象时不可被实例化，即不可创建属于自身的对象。
******************************************************************************

29.	运行时多态性与编译时多态性
知识点：编译时多态性：主要通过【函数重载】和【运算符重载】实现。在编译时，编译器根据【函数】或【运算符】的不同参数类型来选择调用合适的【函数】或【运算符】实现。

运行时多态性：主要通过【虚函数】和【继承】实现。在运行时，程序能够根据对象的实际类型来选择调用相应的函数实现，从而实现多态性。这种形式的多态性需要通过基类指针或引用来调用派生类的函数。
******************************************************************************

30.	数组
知识点：数组是一种数据结构，用于存储相同类型的元素的集合。

数组中的元素通过索引或下标来访问，索引通常从0开始递增。

 数组中的元素在内存中是连续存储的。

数组大小固定，不可被改变。
******************************************************************************

31.	抽象基类
知识点：至少包含一个纯虚函数或包含有虚函数时才能被称为抽象基类。

抽象基类是用来定义接口和提供一些通用实现的。
******************************************************************************

32.	字符串
知识点：const char* a = "ddd";末尾不需要加\0。

char a[] = {'a','b','c','\0'};末尾需要加\0。

char a[] = "ddd";末尾不需要加\0。

其中第二个与第三个char数组等价。

C语言中，字符串通常以字符数组的形式出现，以空字符\0结束（写在末尾）。

std::string a = "ddd";

std::string存在于命名空间中。

std::string是c++的字符串，由标准库提供，使用std::string时，需要加上string头文件(#include <string>)。

使用 std::string 类型的优势在于它提供了更多的高级功能，并且能够动态管理字符串的内存，避免了手动管理字符数组时的许多问题。
******************************************************************************

33.	可见性
知识点：public，公有权限，类内全可见。

private，私有权限。

protected，保护权限。
******************************************************************************

34.	const关键字
知识点：const int a = 10;此时的const是顶层const。

const int* a = nullptr;此时的const为底层const。

如何分辨此时的const究竟是底层const还是顶层const,很简单，只需要观察这个const的作用是影响数据类型本身的作用，还是只对指针或引用发生影响。

继续深入，此时的第一个const之所以是顶层const，是因为他的数据类型是int，而此时const修饰的也是int。

而第二个const本身之所以是底层const，实际上是因为指针这个数据类型本身存放的是地址，但此时的const限制的是这个指针的解引用，这并非指针本身的作用，所以他是底层const。

要分辨，只需要看他修饰的是不是数据类型本身的作用即可。
******************************************************************************

35.	字符串字面量
知识点：const char* a = R"(runoob\n\nn\n)";
R 表示原始字符串字面值，不对其中的转义字符进行转义。这意味着 \n 将被当作两个字符（'' 和 'n'）而不是换行符。

const char* b = u8"(runoob\n\nn\n)";
u8 表示采用 UTF-8 编码的字符串字面值。

const char32_t* c = U"(runoob\n\nn\n)";
U 表示采用 UTF-32 编码的字符串字面值。

const wchar_t* d = L"(runoob\n\nn\n)";
L 表示采用宽字符编码的字符串字面值。

const char16_t* e = u"(runoob\n\nn\n)";
u 表示采用 UTF-16 编码的字符串字面值。
******************************************************************************

36.	Unicode字符集
知识点：UTF-8是可伸缩，而UTF-16,UTF-32则是固定不变.
******************************************************************************

37.	类内的常量成员函数
知识点：const在成员函数的形参列表后，如int func()const{return 0};作用为不能修改该函数内部的成员变量。

在有两个相同名字的函数时，但有一个函数是常量成员函数，那么此时，调用函数会调用那个常量成员函数。
******************************************************************************

38.	mutable关键字
知识点：在 C++ 中，mutable 通常用于修饰类的成员变量，表示这个成员变量即使在常量成员函数中也可以被修改。
******************************************************************************

39.	常量引用
知识点：绑定一个变量之后，无法再修改其值。
******************************************************************************

40.	构造函数的成员初始化列表
知识点：class Person
{
private:
	int a;
	std::string b;
public:
	Person()
		: b("DirectX"),a(4)
	{
	
	}

};
以冒号进行初始化，成员写外面，赋值写小括号内。大部分情况下应该使用成员初始化列表，而非普通的构造函数初始化方式。
******************************************************************************

41.	三元操作符
知识点：三元操作符就是一个冒号和一个问号。                      写法为：a<b?a:b;。
******************************************************************************

42.	typedef与using
知识点：typedef int a;其中a是取的名字，用来替代int，可以使用a b = 0;。

using a = int;就是相当于将typedef反过来写了。
******************************************************************************

43.	c++程序中应该关心的内容
知识点：c++中应该关心内存，优化，性能等问题。
******************************************************************************

44.	new操作符
知识点:在堆上分配内存，并返回指向该内存的指针。需要使用delete 删除 结束。如果分配的是数组格式，那么则需要使用delete[] 删除。
******************************************************************************

45.	隐式转换与explicit关键字
知识点：隐式转换只会进行一次。explicit 可以用在构造函数的声明或定义处，表示禁用隐式转换。
******************************************************************************

46.	运算符重载
知识点：运算符受作用的参数有几个，运算符重载函数就有几个形参，例如加号，就可以确定有两个形参，如果是后置++符号，就可以确认重载运算符的函数形参就是一个形参。大多情况下都是如此。大多情况都是如此。

重载运算符函数写好后，这个符号在使用时，哪些实参使用了这个符号，这个符号的形参就是谁。
******************************************************************************

47.	ostream,cout,ofstream等等
知识点：ostream是输出流类，cout是输出流对象，ofstream同样也是输出流对象，还有很多。
******************************************************************************

48.	this指针
知识点:this指针本身存放的是类的实例化（对象）的地址,并且会隐式调用this指针。

class MyClass {
public:
    int data;

    void setData(int data) {
        this->data = data; // 区分成员变量和参数
    }
};
这就是一个例子，如果不使用this指针，这里依旧会隐式添加this->。
******************************************************************************

49.	unique_ptr智能指针
知识点:unique_ptr智能指针，unique_ptr 对动态分配的整数的独占所有权,超出当前作用域时，自动销毁.
不允许 赋值或复制.
可以移动所有权，使用std::move(移动的对象)函数即可.注意，移动所有权之后，本身会变成空指针。
例如:int main()
{
        std::unique_ptr<int> uniquePtr = std::make_unique<int>(42);
        // uniquePtr 拥有对动态分配的整数的独占所有权

        // 不允许复制或赋值
        // std::unique_ptr<int> anotherPtr = uniquePtr; // 错误

        // 可以移动所有权
        std::unique_ptr<int> anotherPtr = std::move(uniquePtr);

        // 当 uniquePtr 超出范围时，动态分配的整数会被销毁
        std::cout << *anotherPtr << std::endl; //42

    return 0;
}
此时，uniquePtr因为移动了所有权给anotherPtr，所以现在uniquePtr是空指针。
******************************************************************************

50.	shared_ptr智能指针
知识点:shared_ptr智能指针，shared_ptr 对动态分配的整数共享所有权，超出当前作用域，自动销毁。
允许赋值和复制。
同样可以移动所有权，与unique_ptr同理。
例如:int main()
{
    std::shared_ptr<int> sharedPtr1 = std::make_shared<int>(42);
    // sharedPtr1 拥有对动态分配的整数的共享所有权

    std::shared_ptr<int> sharedPtr2 = sharedPtr1;  // 共享所有权

						//计数2
    std::cout << *sharedPtr1 << std::endl;
    std::cout << *sharedPtr2 << std::endl;

    // 当最后一个 shared_ptr 超出范围时，动态分配的整数会被销毁
    return 0;
}
******************************************************************************

51.	weak_ptr智能指针
知识点:看到这的都会很懵逼对这个，因为我当时也懵逼了。
weak_ptr内部其实有个隐藏的内部shared_ptr指针，当为weak_ptr赋值时，内部这个shared_ptr会接收外部的shared_ptr.
weak_ptr使用lock函数时，等于将内部的shared_ptr接收的外部shared_ptr的地址调用出来，所以对使用lock函数的weak_ptr解引用时，获得的值是外部的shared_ptr的值（地址内的值）。
******************************************************************************


52.	reset函数
知识点:对于 std::weak_ptr，reset() 的作用是放弃对所共享对象的引用，将 std::weak_ptr 重置为初始状态。它不会影响共享对象的引用计数。
重置 shared_ptr： 如果调用 reset() 的是一个 std::shared_ptr，它将放弃对所管理对象的所有权。
reset() 还可以接受一个指向新对象的指针，并使 shared_ptr 开始管理新的对象。
******************************************************************************

53.	c++复制与拷贝构造函数
知识点：必须是类的实例化初始化时才能引发复制构造函数调用，赋值不会引发复制构造函数的调用。

具体前往:https://c.biancheng.net/view/151.html网站看
******************************************************************************

54.	偏移量
知识点:偏移量就是指，该成员在类内所占字节数排在那，例a，b，c都是int，那么c就在8

求偏移量的公式：size_t offset = offsetof(B, c);  B是类或结构体 ， c是内部的元素。
******************************************************************************

55.	箭头操作符
知识点:必须指向有效的目标，否则会报错。

指向的成员必须存在。

箭头操作符自带解引用功能。(*ptr).元素.

在类或结构体中，或类的实例化指向了某个实例化时，才能使用箭头操作符。
举例:类B。      B* b = new B;这是b访问元素或成员函数等等时，才能够使用箭头操作符。
******************************************************************************

56.	动态数组(vector)-(容器)
知识点：使用vector之前需要添加头文件#include <vecotr>.

vector在堆上创建。

(在元素末尾)添加元素函数 push_back函数.

（指定删除）指定删除元素函数erase函数.

（删除全部元素）删除全部元素函数clean函数.

待添加...... 
******************************************************************************

57.	库
知识点:动态链接库后缀为.dll , 静态链接库后缀为.lib.

头文件:编译时使用.  报错为c（编译）错误               lib文件:链接时使用.  报错为link（链接）错误            dll文件：运行时使用.  报错为打开一个.exe文件时出现报错弹窗

c++到可执行的过程：源文件.cpp --> 预处理器 --> 中间文件.i --> 编译器 --> 目标文件.obj + 库文件.lib --> 链接器 --> 可执行文件.exe.

创建好.lib或.dll项目后，优先更改输出设置与中间目录，并且创建一个与主cpp（该项目，非main函数所在的项目）项目的.h文件，声明全部写进去，定义全部写到cpp文件。
具体忽略，库这一节的笔记别看，写的不好。
******************************************************************************

58.	处理多个返回值
知识点：使用tuple解决.使用前，需加上头文件#include <tuple>

代码示例：
std::tuple<int, double, char> myFunction()
{
	return std::make_tuple(42, 3.14, 'A');
}

int main()
{
	/       可使用auto        \
	std::tuple<int,double,char> result = myFunction();
	std::cout << "Value 1: " << std::get<0>(result) << std::endl;
	std::cout << "Value 2: " << std::get<1>(result) << std::endl;
	std::cout << "Value 3: " << std::get<2>(result) << std::endl;
	std::cout << std::get<0>(myFunction()) << std::endl;
	return 0;
}

std::get<0>(result) 是用于从 std::tuple 中获取第一个元素的语法。
******************************************************************************

59.	模板
知识点:只有被使用时才会创建实例，不被使用时，尽管函数内参数出错，也不会显示错误。

创建模板：template <typename T>

函数模板可以自动为形参选择合适的类型。
类模板需要指定实际类型。

类模板案例：
1. 类模板（Class Templates）：
定义： 类模板允许你定义一种通用的类，其中可以使用一个或多个类型参数。
cpp
Copy code
template <typename T>
class MyTemplate {
public:
    T data;
    void setData(T value) {
        data = value;
    }
};
实例化： 在使用时，你需要指定实际类型，这样编译器才能为每个具体的类型生成对应的类。

cpp
Copy code
MyTemplate<int> intObj;
MyTemplate<double> doubleObj;
示例用途： 类模板常用于容器类（如 std::vector<T>）、智能指针（如 std::shared_ptr<T>）、模板类的封装等情况。

函数模板案例：

类模板和函数模板都是 C++ 中的泛型编程工具，但它们有一些区别。

1. 类模板（Class Templates）：
定义： 类模板允许你定义一种通用的类，其中可以使用一个或多个类型参数。

cpp
Copy code
template <typename T>
class MyTemplate {
public:
    T data;
    void setData(T value) {
        data = value;
    }
};
实例化： 在使用时，你需要指定实际类型，这样编译器才能为每个具体的类型生成对应的类。

cpp
Copy code
MyTemplate<int> intObj;
MyTemplate<double> doubleObj;
实例化后，调用成员函数或成员变量无需再指定实际类型。
示例用途： 类模板常用于容器类（如 std::vector<T>）、智能指针（如 std::shared_ptr<T>）、模板类的封装等情况。

2. 函数模板（Function Templates）：
定义： 函数模板允许你编写一个通用的函数，其中可以使用一个或多个类型参数。
cpp
Copy code
template <typename T>
T add(T a, T b) {
    return a + b;
}
实例化： 函数模板在调用时自动推断模板参数类型，无需显式指定。

cpp
Copy code
int result1 = add(3, 4);       // 实例化为 add<int>(3, 4)
double result2 = add(2.5, 3.5); // 实例化为 add<double>(2.5, 3.5)
示例用途： 函数模板常用于泛型算法、数学运算、容器算法等场景。
******************************************************************************

60.	宏
知识点：#define abxc \
int             其中\在宏定义中，等于回车。

#define a int   
基本格式，不过大多情况不这样使用，大多情况按以下方式使用：
#if PR_DEBUG == 1
#define LoG(x) std::cout << x << std::endl
#elif defined(PR_RELEASE)
#define LoG(x) std::cout << x << std::endl
#endif

语句：
#if 0
#endif
作用为：当是0时，语句无效，为1时，语句生效。

******************************************************************************

61.	auto关键字
知识点:自动适配类型。

函数使用:auto fu() ->std::string
{
	return "cherno";
}
对象使用：auto a = fu();

使用技巧：一般类型名字超级长，使用auto来方便。

缺点：让代码变得难以理解。
******************************************************************************

62.	array(静态数组)（容器）
知识点:与vector类似，不过array需要被指定大小,称为固定大小的容器(array).使用array之前需要＋头文件#include <array>。

array在栈上创建。应该使用c++的array，而非c风格的数组（int arr[10]）这种。 array的size直接返回大小参数。

代码示例:
		/大小为42个元素\
std::array<int,42>b;  	//不可更改数组大小
******************************************************************************

63.	函数指针
知识点:函数指针定义：  int(*func)(  ) =  &函数名。		这个函数名是已经存在的函数的名字，函数指针可以理解为在函数中的指针。

int foo(){
    return 5;
}
int main()
{
    int (*funcPtr1)() = foo;
    int (*funcPtr2)() = &foo;重点: // c++会隐式得把foo转换成&foo，所以你无需再加入&
    std::cout << funcPtr1() << std::endl;
    std::cout << funcPtr2() << std::endl;
}

由上面得到，函数名字本身是一串地址，加上括号就类似于指针的解引用一样，将一个函数名传递给一个函数指针，等于更换这个函数指针的指向。并且c++会隐式转换，所以以后获取函数的地址需要加上&符号（最好加上）.

typedef void(*func)( 形参列表  );           使用时：func a   =  函数名;          
******************************************************************************

64.	lambda
知识点:lambda定义格式:     auto it = [ 捕获列表 ]( 形参列表 ) ->返回类型{ 返回值或语句 }; 

捕获列表: =符号表示所有外部值都不可变（在lambda表达式中不可变），&符号则表示都可以改变。符号后面跟上一个值，例如&a表示只有a这个值可以在lambda中改变。符号大致有=,&,this等等。
如果捕获列表未存在任何符号，例如只有[  ]，那么该lambda表达式则无法获取任何外来值。

形参列表：照旧。与正常的函数形参列表差不多。

->返回类型: 显示返回类型，不添加也可以，不添加时，会自动判断其返回类型。
******************************************************************************

65.	命名空间
知识点:命名空间定义格式: using namespace{    };

使用命名空间的方式: 
第一种:using namespace 命名空间的名字;             如果是std命名空间，则using namespace std;       作用为std命名空间内的东西全部引入权限。
第二种:using std::cout;  单个引入，只引入std命名空间内的cout。

自己定义自己的命名空间方式:
namespace apple{  代码  };
之后的代码只要是用到apple这个命名空间内的代码，请自动加上apple::代码名字  。

绝不允许在头文件（.h）中使用命名空间，请养成不适用命名空间的良好习惯。
在大型项目，多人共同开发的项目中，命名空间起到了避免代码名字相同产生的冲突。
******************************************************************************

66.	线程
知识点:使用线程之前添加头文件#include <thread> , thread存在于std命名空间中。

线程接受一个函数指针:
如:std::thread a(函数指针);

对该线程操控：(this_thread)

获取该线程id信息： std::thread::id it = std::this_thread::gte_id(  );

join函数：一个阻塞调用，主要用于主线程等待被调用的子线程执行完毕。

待续......
******************************************************************************

67.	计时
知识点：chrono（计时），使用时需要添加头文件#include <chrono>.
当前线程延迟：
c++14新特性的写法
int main()
{
    //c++14 新特性
    using namespace std::literals::chrono_literals;

    //线程延时
    std::this_thread::sleep_for(1s); //延时一秒

    std::cin.get();
    return 0;
}

c++不使用新特性
int main()
{
    //线程延时
    std::this_thread::sleep_for(std::chrono::seconds(1)); //延时一秒

    std::cin.get();
    return 0;
}

获取时间点（用于测试时间间隔）:
std::chrono::high_resolution_clock::now()， 使用std::chrono::time_point<std::chrono::steady_clock>接收返回的值。
如果你需要最高可能的精度，并且可以接受由于系统调整时间而导致的不连续性，可以选择使用 high_resolution_clock。
如果你更关心时间的稳定性，不希望受到系统时间调整的干扰，可以选择使用 steady_clock。

std::chrono::duration 是 C++ 标准库中用于表示时间段（duration）的模板类。它是一个通用的时间段表示工具，可以表示秒、毫秒、微秒、纳秒等不同时间单位的时间间隔。

待续......
******************************************************************************

68.	多维数组
知识点:
******************************************************************************


