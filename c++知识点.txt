c++

1.	#include <iostream>
	#include <string>
知识点： #后方是预处理语句，意思是在编译之前就已经处理过了，所以才叫预处理。
******************************************************************************

2.	#include <iostream>
知识点：包含了iostream头文件后，才可以使用cout，cin等等。
******************************************************************************

3.	编译有四个阶段：预处理，编译阶段（C），汇编，链接阶段（LNK）.
编译的主要目的之一就是将高级编程语言的源代码转换为机器能够执行的二进制代码。这个过程包括了几个步骤：

预处理（Preprocessing）： 展开宏定义、处理条件编译等，生成经过预处理的源代码。

编译（Compilation）： 将预处理后的源代码翻译为汇编代码。

汇编（Assembly）： 将汇编代码翻译为机器码，生成目标文件（通常是 .obj 文件）。

链接（Linking）： 将所有目标文件和所需的库文件链接在一起，生成最终的可执行文件（通常是 .exe 文件）。

知识点：c2039就是指编译阶段出错。LNK2039就是链接阶段出错。这里的数字只是例子，不是具体数字。
******************************************************************************

4.	不同类型的变量之间的区别只有一种：大小。即该数据类型占多少内存。（原始数据类型的区别）
知识点：int     4字节，short   2字节

int-short>0（a-b>0），求得int占内存比short大，并且int取值范围也比short大。（实际数据类型所占字节根据编译器而定）

int范围在2b~-2b之间，即所占字节（4）先*8，求得所占位数为32，然后2^32/2-1求得int所在N集合范围的取值,然后求非正集合Z（不包括0）的取值范围为-（2^32）/2

之所以-1，是因为N集合包括0，在最大数上要-1来确保0计入。

集合表示为{x∈Z|-(2^32)/2<=x<=2^32/2-1}
******************************************************************************

5.	函数
知识点：多次反复利用，避免代码重复，函数一般称为代码块，在类中被称为方法。
******************************************************************************

6.	#pragma once
知识点：#pragma预处理指令是向编译器发送命令，#pragma once存在于头文件最顶端，是告诉编译器只包含一次该头文件。
******************************************************************************

7.	头文件.h
知识点：头文件中写声明，定义写在obj文件（源文件）或主函数所在文件中。
******************************************************************************

8.	visual studio文件
知识点：pdb文件提供调试所需信息，ilk可以增量编译，优化链接，idb文件进行支持增量编译。obj文件是.cpp文件被编译后形成的。obj文件内是二进制。
******************************************************************************

9.	双引号头文件与尖括号头文件
知识点：双引号头文件在当前项目中目录结构进行查找，尖括号头文件直接在整个系统中进行查找。
******************************************************************************

10.	调试的两大部分：断点与读取内存
知识点：调试时，断点所处位置出现黄色箭头，意思是将要执行此行代码。断点同时是为了查看程序是否按照预期执行，设置断点就是为了读取内存。visual studio2022中断点的快捷键是f9。
******************************************************************************

11.	debug
知识点：在程序中调试进行查找bug。
******************************************************************************

12.	visual studio2022输出and中间目录最佳设置
知识点:舒服就对了，输出目录为：$(SolutionDir)bin\$(Platform)\$(Configuration)\           中间目录为:$(SolutionDir)bin\intermediates\$(Platform)\$(Configuration)\ 
******************************************************************************

13.	循环
知识点：for循环，while循环，do while循环（唯独这个，先执行一次再判断）。需要多次执行时使用循环语句。
******************************************************************************

14.	控制流语句
知识点：continue，break，return。continue只能在循环中使用，作用为跳转至循环下一次迭代。break只能在循环或switch中使用，break的作用为终止循环。return为跳出函数。
******************************************************************************

15.	指针
知识点：获取地址，指针内部存放的是地址。
******************************************************************************

16.	16进制
知识点：0x3e8 = 1000.   3*16*16+e*16+8.   运算为百位*2个16，十位*1个16，个位不需要*。千位以此递推。*16的个数为当前位数-1.百位为3，-1 = 2， 所以百位上的数字*2个16.
******************************************************************************

17.	引用
知识点：为对象起别名，在实际编译中，引用的名字不存在，假设有变量a，还有引用ref，ref是a的引用，在实际编译中，只会出现a，ref不存在。引用只能绑定一个对象。
******************************************************************************

18.	面向对象
知识点：三大特性：封装，继承，多态。c++为面向对象语言，其他的语言还有c#，java......
******************************************************************************

19.	类
知识点：增加了可维护性，可以实现的功能用不用类都能实现。            类（Class）： 一个抽象的数据类型，描述了数据的结构和对数据执行的操作。            对象（Object）： 类的一个具体实例，占用内存空间，可以执行类定义的操作。
******************************************************************************

20.	类（class）与结构体（struct）
知识点：唯一的区别只有结构体默认为公有属性（public），类默认为私有（private）属性。之所以c++中依旧保持结构体，是因为保持对c的兼容，只需使用#define struct class即可。
******************************************************************************

21.	静态（static）
知识点：类，结构体内创建的静态为静态成员变量或静态成员函数，每个静态都在每个对象中共同存在，享用同一段内存。局部静态，只被初始化一次。全局静态，只存在于当前.cpp文件内，其他.cpp文件无法访问。静态成员变量和函数是属于类的，而非类的实例。
******************************************************************************

22.	运行阶段
知识点：运行阶段：在运行阶段，你执行生成的可执行文件。这时候不再需要编译或链接，只需运行已经生成好的二进制文件。操作系统加载可执行文件到内存中，并按照程序的入口点开始执行。
******************************************************************************

23.	枚举
知识点：全局调用时，无论是具名枚举还是匿名枚举，常量名称在相同的作用域内必须是唯一的。而枚举类引入了独立的作用域，允许不同的枚举类拥有相同的常量名称。
******************************************************************************

24.	构造函数
知识点：开始时调用一次，为当前对象的成员变量赋初始值。
******************************************************************************

25.	析构函数
知识点：结束时调用一次，在对象销毁的过程中，负责释放对象所拥有的资源，关闭文件，或执行其他必要的清理操作。
******************************************************************************

26.	继承
知识点：公有（public）继承，基类的公有成员在派生类当中依旧是公有的，基类的私有成员不继承给派生类，基类的保护成员全部为派生类的保护成员。私有成员不会被继承。

私有（private）继承，基类的公有成员，保护成员，全部变为派生类的私有成员。私有成员不会被继承。

保护（protected）继承，基类的公有成员，保护成员，全部变为派生类的保护成员。私有成员不会被继承。

共同点是，私有属性不管在什么继承中，都不会被继承，私有只存在于该类本身之中。
******************************************************************************

27.	虚函数
知识点：派生类不会被强制要求必须提供实现，派生类中没有实现时，会调用基类的虚函数本身的成员。通过基类指针或引用调用一个虚函数，实际上将调用与指针或引用关联的对象的类型中的函数，而不是指针或引用本身的类型。

同时，基类的析构函数也要变成虚析构函数，派生类的析构函数要加上关键字override.
******************************************************************************

28.	纯虚函数
知识点：要求任何派生类都必须提供自己的实现。

所处基类创建对象时不可被实例化，即不可创建属于自身的对象。
******************************************************************************

29.	运行时多态性与编译时多态性
知识点：编译时多态性：主要通过【函数重载】和【运算符重载】实现。在编译时，编译器根据【函数】或【运算符】的不同参数类型来选择调用合适的【函数】或【运算符】实现。

运行时多态性：主要通过【虚函数】和【继承】实现。在运行时，程序能够根据对象的实际类型来选择调用相应的函数实现，从而实现多态性。这种形式的多态性需要通过基类指针或引用来调用派生类的函数。
******************************************************************************

30.	数组
知识点：数组是一种数据结构，用于存储相同类型的元素的集合。

数组中的元素通过索引或下标来访问，索引通常从0开始递增。

 数组中的元素在内存中是连续存储的。

数组大小固定，不可被改变。
******************************************************************************

31.	抽象基类
知识点：至少包含一个纯虚函数或包含有虚函数时才能被称为抽象基类。

抽象基类是用来定义接口和提供一些通用实现的。
******************************************************************************

32.	字符串
知识点：const char* a = "ddd";末尾不需要加\0。

char a[] = {'a','b','c','\0'};末尾需要加\0。

char a[] = "ddd";末尾不需要加\0。

其中第二个与第三个char数组等价。

C语言中，字符串通常以字符数组的形式出现，以空字符\0结束（写在末尾）。

std::string a = "ddd";

std::string存在于命名空间中。

std::string是c++的字符串，由标准库提供，使用std::string时，需要加上string头文件(#include <string>)。

使用 std::string 类型的优势在于它提供了更多的高级功能，并且能够动态管理字符串的内存，避免了手动管理字符数组时的许多问题。
******************************************************************************

33.	可见性
知识点：public，公有权限，类内全可见。

private，私有权限。

protected，保护权限。
******************************************************************************

34.	const关键字
知识点：const int a = 10;此时的const是顶层const。

const int* a = nullptr;此时的const为底层const。

如何分辨此时的const究竟是底层const还是顶层const,很简单，只需要观察这个const的作用是影响数据类型本身的作用，还是只对指针或引用发生影响。

继续深入，此时的第一个const之所以是顶层const，是因为他的数据类型是int，而此时const修饰的也是int。

而第二个const本身之所以是底层const，实际上是因为指针这个数据类型本身存放的是地址，但此时的const限制的是这个指针的解引用，这并非指针本身的作用，所以他是底层const。

要分辨，只需要看他修饰的是不是数据类型本身的作用即可。
******************************************************************************

35.	字符串字面量
知识点：const char* a = R"(runoob\n\nn\n)";
R 表示原始字符串字面值，不对其中的转义字符进行转义。这意味着 \n 将被当作两个字符（'' 和 'n'）而不是换行符。

const char* b = u8"(runoob\n\nn\n)";
u8 表示采用 UTF-8 编码的字符串字面值。

const char32_t* c = U"(runoob\n\nn\n)";
U 表示采用 UTF-32 编码的字符串字面值。

const wchar_t* d = L"(runoob\n\nn\n)";
L 表示采用宽字符编码的字符串字面值。

const char16_t* e = u"(runoob\n\nn\n)";
u 表示采用 UTF-16 编码的字符串字面值。
******************************************************************************

36.	Unicode字符集
知识点：UTF-8是可伸缩，而UTF-16,UTF-32则是固定不变.
******************************************************************************

37.	类内的常量成员函数
知识点：const在成员函数的形参列表后，如int func()const{return 0};作用为不能修改该函数内部的成员变量。

在有两个相同名字的函数时，但有一个函数是常量成员函数，那么此时，调用函数会调用那个常量成员函数。
******************************************************************************

38.	mutable关键字
知识点：在 C++ 中，mutable 通常用于修饰类的成员变量，表示这个成员变量即使在常量成员函数中也可以被修改。
******************************************************************************

39.	常量引用
知识点：绑定一个变量之后，无法再修改其值。
******************************************************************************

40.	构造函数的成员初始化列表
知识点：class Person
{
private:
	int a;
	std::string b;
public:
	Person()
		: b("DirectX"),a(4)
	{
	
	}

};
以冒号进行初始化，成员写外面，赋值写小括号内。大部分情况下应该使用成员初始化列表，而非普通的构造函数初始化方式。
******************************************************************************

41.	三元操作符
知识点：三元操作符就是一个冒号和一个问号。                      写法为：a<b?a:b;。
******************************************************************************

42.	typedef与using
知识点：typedef int a;其中a是取的名字，用来替代int，可以使用a b = 0;。

using a = int;就是相当于将typedef反过来写了。
******************************************************************************

43.	c++程序中应该关心的内容
知识点：c++中应该关心内存，优化，性能等问题。
******************************************************************************

44.	new操作符
知识点:在堆上分配内存，并返回指向该内存的指针。需要使用delete 删除 结束。如果分配的是数组格式，那么则需要使用delete[] 删除。
******************************************************************************

45.	隐式转换与explicit关键字
知识点：隐式转换只会进行一次。explicit 可以用在构造函数的声明或定义处，表示禁用隐式转换。
******************************************************************************

46.	运算符重载
知识点：运算符受作用的参数有几个，运算符重载函数就有几个形参，例如加号，就可以确定有两个形参，如果是后置++符号，就可以确认重载运算符的函数形参就是一个形参。大多情况下都是如此。大多情况都是如此。

重载运算符函数写好后，这个符号在使用时，哪些实参使用了这个符号，这个符号的形参就是谁。
******************************************************************************

47.	ostream,cout,ofstream等等
知识点：ostream是输出流类，cout是输出流对象，ofstream同样也是输出流对象，还有很多。
******************************************************************************

48.	this指针
知识点:this指针本身存放的是类的实例化（对象）的地址,并且会隐式调用this指针。

class MyClass {
public:
    int data;

    void setData(int data) {
        this->data = data; // 区分成员变量和参数
    }
};
这就是一个例子，如果不使用this指针，这里依旧会隐式添加this->。
******************************************************************************

49.	unique_ptr智能指针
知识点:unique_ptr智能指针，unique_ptr 对动态分配的整数的独占所有权,超出当前作用域时，自动销毁.
不允许 赋值或复制.
可以移动所有权，使用std::move(移动的对象)函数即可.注意，移动所有权之后，本身会变成空指针。
例如:int main()
{
        std::unique_ptr<int> uniquePtr = std::make_unique<int>(42);
        // uniquePtr 拥有对动态分配的整数的独占所有权

        // 不允许复制或赋值
        // std::unique_ptr<int> anotherPtr = uniquePtr; // 错误

        // 可以移动所有权
        std::unique_ptr<int> anotherPtr = std::move(uniquePtr);

        // 当 uniquePtr 超出范围时，动态分配的整数会被销毁
        std::cout << *anotherPtr << std::endl; //42

    return 0;
}
此时，uniquePtr因为移动了所有权给anotherPtr，所以现在uniquePtr是空指针。
******************************************************************************

50.	shared_ptr智能指针
知识点:shared_ptr智能指针，shared_ptr 对动态分配的整数共享所有权，超出当前作用域，自动销毁。
允许赋值和复制。
同样可以移动所有权，与unique_ptr同理。
例如:int main()
{
    std::shared_ptr<int> sharedPtr1 = std::make_shared<int>(42);
    // sharedPtr1 拥有对动态分配的整数的共享所有权

    std::shared_ptr<int> sharedPtr2 = sharedPtr1;  // 共享所有权

						//计数2
    std::cout << *sharedPtr1 << std::endl;
    std::cout << *sharedPtr2 << std::endl;

    // 当最后一个 shared_ptr 超出范围时，动态分配的整数会被销毁
    return 0;
}
******************************************************************************

51.	weak_ptr智能指针
知识点:看到这的都会很懵逼对这个，因为我当时也懵逼了。
weak_ptr内部其实有个隐藏的内部shared_ptr指针，当为weak_ptr赋值时，内部这个shared_ptr会接收外部的shared_ptr.
weak_ptr使用lock函数时，等于将内部的shared_ptr接收的外部shared_ptr的地址调用出来，所以对使用lock函数的weak_ptr解引用时，获得的值是外部的shared_ptr的值（地址内的值）。
******************************************************************************


52.	reset函数
知识点:对于 std::weak_ptr，reset() 的作用是放弃对所共享对象的引用，将 std::weak_ptr 重置为初始状态。它不会影响共享对象的引用计数。
重置 shared_ptr： 如果调用 reset() 的是一个 std::shared_ptr，它将放弃对所管理对象的所有权。
reset() 还可以接受一个指向新对象的指针，并使 shared_ptr 开始管理新的对象。
******************************************************************************

53.	c++复制与拷贝构造函数
知识点：
******************************************************************************